---
title: "Tests with DTW"
output:
  html_document:
    df_print: paged
    number_sections: true
    toc: true
    toc_depth: 6
    toc_float: true
  md_document:
    df_print: paged
  pdf_document:
    number_sections: true
    toc: true
    toc_depth: 6
  word_document: default
---

In this notebook we want to test whether we can detect patterns in noisy data using dynamic time warping. We will generate some synthetic data for that.

```{r warning=FALSE, message=FALSE}
library(dtw)
```

# Create an Example Signal

In the following example, we assume the signal to look like Gauss bell, and that's what we'll be looking for later. The bell is generated by estimating a density over a normally distributed sample of 500 points. The shape is obtained by 256 equally spaced points at which the density is to be estimated over the sample.

```{r}
set.seed(1)

d <- density(rnorm(500), n = 256)

noisy_signal <- list(
  x = 1:(length(d$x) + 768),
  y = c(
    # Add random noise before:
    rnorm(n = 256, sd = 0.05) + (0.05 * rexp(n = 256)),
    # Add the actual signal with some noise:
    d$y + rnorm(n = length(d$x), sd = 0.05),
    # Add random noise after:
    rnorm(n = 512, sd = 0.05) + (0.15 * runif(n = 512))
  )
)

if (min(noisy_signal$y) < 0) {
  noisy_signal$y <- noisy_signal$y + abs(min(noisy_signal$y))
}

plot(noisy_signal)
```

# Create the Original Signal we want to find

Let's attempt to find Gauss bell. We will use a similar distribution first, before we alter it using $\mu$ and $\sigma$.

NOTE: In the few following tests, we are not using windowing, so the DTW algorithm attempts to match two sequences start to end!

```{r}
set.seed(2)

d1 <- density(rnorm(500, mean = 3), n = 256)

org_signal <- list(
  x = 1:length(d1$x),
  y = d1$y
)
```

# Use Dynamic Time Warping to find the pattern

```{r}
find_signal <- dtw::dtw(x = noisy_signal$y, y = org_signal$y, keep.internals = TRUE)

#par(mfrow=c(3,1))

plot(org_signal)

plot(noisy_signal)

plot(find_signal, type = "alignment")
plot(find_signal, type = "three")

print(c(find_signal$distance, find_signal$normalizedDistance))
```

## Define functions for assessing goodness-of-match

Before we go further, we want to extract the matching portions of the pattern from the window and compare it to the original signal. We approximate functions for the original and the matched signal and then calculate the difference as the area between the curves in a unit square.

```{r}
extract_signal_from_window <- function(dtwAlign, window, throwIfFlat = FALSE) {
  # First, we check whether the warping function is flat. This
  # test has two components: a linear regression, and a check
  # of the vertical co-domain of that function.
  tempLm <- stats::lm(
    formula = y ~ x, data = data.frame(
      x = 1:length(dtwAlign$index2),
      y = dtwAlign$index2
    )
  )
  if (tempLm$coefficients[2] < .1) {
    # The slope is less than 0.1.
    # It is very flat, let's check the values in the co-domain:
    if (((max(dtwAlign$index2) - min(dtwAlign$index2)) / nrow(dtwAlign$reference)) < .1) {
      # Also, the values in the co-domain cover less than 10%
      # of the available range, indicating an actual flat line.
      # We will return two values, both 0, so that a function
      # can be approximated.
      wMsg <- "DTW warping function is flat."
      if (throwIfFlat) {
        stop(wMsg)
      }
      warning(wMsg)
      
      return(list(
        indices = c(0, 0),
        start = 0,
        end = 0,
        data = c(0, 0)
      ))
    }
  }
  
  
  indices <- c()
  for (idx in 1:min(length(window) - 1, length(dtwAlign$index2) - 1)) {
    if (dtwAlign$index2[idx] < dtwAlign$index2[idx + 1]) {
      indices <- c(indices, c(idx, idx + 1))
    }
  }
  
  indices <- unique(indices)
  
  #return(window[indices])
  return(list(
    indices = indices,
    start = min(indices),
    end = max(indices),
    data = window[indices]
  ))
}
```

Now we need to transform both, the original pattern and the matched pattern to be in the $[0,1]$ range.

After this, we want to approximate two functions. For the original pattern we use `approxfun`, and for the matched pattern we use a Loess-smoothed approximation.

```{r}
pattern_approxfun <- function(yData, smooth = FALSE) {
  if (all(yData == 0)) {
    return(approxfun(
      x = c(0, 1),
      y = c(0, 0)
    ))
  }
  
  if (smooth) {
    temp <- loess.smooth(
      x = 1:length(yData),
      y = yData,
      span = 0.15
    )
    
    yData <- temp$y
    xData <- temp$x - min(temp$x)
    xData <- xData / max(xData)
  } else {
    xData <- seq(0, 1, by = 1 / (length(yData) - 1))
  }
  
  yData <- yData - min(yData)
  yData <- yData / max(yData)
  
  return(approxfun(
    x = xData,
    y = yData
  ))
}
```

Now that we can approximate both patterns as a function in the unit square, we will look for intersections, so that we can integrate and sum up all differences between the two functions.

```{r}
area_diff_2_functions <- function(f1, f2) {
  # Find the intersections of both functions:
  intersections <- rootSolve::uniroot.all(
    f = function(x) f1(x) - f2(x),
    interval = c(0, 1))
  
  if (length(intersections) == 0) {
    # One function is complete below/above the other
    intersections <- c(0, 1)
  }
  
  # Check that lower/upper integration boundaries exist:
  if (intersections[1] > 0) {
    intersections <- c(0, intersections)
  }
  if (utils::tail(intersections, 1) < 1) {
    intersections <- c(intersections, 1)
  }
  
  # Now, for each pair of intersections, we integrate both
  # functions and sum up the areas.
  
  area <- 0
  for (intsec in 1:(length(intersections) - 1)) {
    temp <- abs(
      stats::integrate(
        f = f1,
        lower = intersections[intsec],
        upper = intersections[intsec + 1])$value
      -
      stats::integrate(
        f = f2,
        lower = intersections[intsec],
        upper = intersections[intsec + 1])$value)
    
    area <- area + temp
  }
  
  return(area)
}
```

### Example using no Window

Let's do a full example using the match from above. We do not have a window, so we use the entire warping function to extract matches of our sought-after pattern. We will use smoothing since no window is used:

```{r fig.keep='all'}
signal_org_f <- pattern_approxfun(org_signal$y)

signal_ext3 <- extract_signal_from_window(find_signal, window = stats::window(noisy_signal$y))
signal_mat3 <- signal_ext3$data
signal_mat_f3 <- pattern_approxfun(signal_mat3, smooth = TRUE)

print(paste0("The difference in area is (max 1): ", area_diff_2_functions(signal_org_f, signal_mat_f3)))

curve(signal_org_f, 0, 1, col = "red")
curve(signal_mat_f3, 0, 1, add = TRUE)

print(paste0("The window starts at ", signal_ext3$start, " and ends at ", signal_ext3$end))
```

### Example using a Window

Try the same with a window that closer encapsulates the pattern (the pattern starts at 256 with a length of 256):

```{r}
win <- stats::window(noisy_signal$y, start = 220, end = 594)
plot(list(
  x = 1:length(win),
  y = win
))

# Note how we use a different step.pattern.
# The default is 'symmetric2'.
# It should be remarked that the Sakoe-Chiba band works well when N ~ M, but is inappropriate when the lengths of the two inputs differ significantly. In particular, when |N - M| > T_0.
# Argument 'dist.method' does not make since with univariate time series
find_signal_w <- dtw::dtw(
  x = win, y = org_signal$y, keep.internals = TRUE,
  step.pattern = asymmetric,
  #step.pattern = rabinerJuangStepPattern(1, slope.weighting = "c", smoothed = TRUE),
  open.end = TRUE,
  open.begin = TRUE)

plot(find_signal_w, type = "alignment")
plot(find_signal_w, type = "two")
plot(find_signal_w, type = "three")

print(c(find_signal_w$distance, find_signal_w$normalizedDistance))
```


Let's do a full example using the match from above:

```{r fig.keep='all'}
signal_org_f <- pattern_approxfun(org_signal$y)

signal_ext <- extract_signal_from_window(find_signal_w, window = win)
signal_mat <- signal_ext$data
signal_mat_f <- pattern_approxfun(signal_mat, smooth = TRUE)

curve(signal_org_f, 0, 1, col = "red")
curve(signal_mat_f, 0, 1, add = TRUE)

print(paste0("The window starts at ", signal_ext$start, " and ends at ", signal_ext$end))
```
Now the area between the curves in the unit square is:
```{r}
area_diff_2_functions(signal_org_f, signal_mat_f)
```


### Example using a partially matching window:

Try the same with a window that only PARTIALLY contains the pattern:

```{r}
win2 <- stats::window(noisy_signal$y, start = 384, end = 800)
plot(list(
  x = 1:length(win2),
  y = win2
))

find_signal_w2 <- dtw::dtw(
  x = win2, y = org_signal$y, keep.internals = TRUE,
  step.pattern = asymmetric,
#  step.pattern = rabinerJuangStepPattern(1, slope.weighting = "c", smoothed = TRUE),
  open.end = TRUE,
  open.begin = TRUE)

plot(find_signal_w2, type = "alignment")
plot(find_signal_w2, type = "two")
plot(find_signal_w2, type = "three")

print(c(find_signal_w2$distance, find_signal_w2$normalizedDistance))
```

```{r fig.keep='all'}
signal_ext2 <- extract_signal_from_window(find_signal_w2, window = win2)
signal_mat2 <- signal_ext2$data
signal_mat_f2 <- pattern_approxfun(signal_mat2, smooth = FALSE)

area_diff_2_functions(signal_org_f, signal_mat_f2)

curve(signal_org_f, 0, 1, col = "red")
curve(signal_mat_f2, 0, 1, add = TRUE)

print(paste0("The window starts at ", signal_ext2$start, " and ends at ", signal_ext2$end))
```

### Example with a window that does not contain the pattern:

Try the same with a window that does NOT contain the pattern:
```{r}
win1 <- stats::window(noisy_signal$y, start = 650, end = 1024)
plot(list(
  x = 1:length(win1),
  y = win1
))

find_signal_w1 <- dtw::dtw(
  x = win1, y = org_signal$y, keep.internals = TRUE,
  step.pattern = asymmetric,
#  step.pattern = rabinerJuangStepPattern(1, slope.weighting = "c", smoothed = TRUE),
  open.end = TRUE,
  open.begin = TRUE)

plot(find_signal_w1, type = "alignment")
plot(find_signal_w1, type = "two")
plot(find_signal_w1, type = "three")

print(c(find_signal_w1$distance, find_signal_w1$normalizedDistance))
```

As we can see, the warping function is flat, indicating that DTW can not match the sought-after pattern to the given signal. ___In that case, any distance metric should indicate the maximum possible distance___, and we demonstrate this case below, catching the error. Then, we show what happens if we just go ahead and ignore the error, and estimate the difference in areas (it still works as expected).

```{r}
# This'll throw:
tryCatch({
  signal_mat1 <- extract_signal_from_window(
    find_signal_w1, window = win1, throwIfFlat = TRUE)
}, error = function(cond) {
  warning(cond)
})
```

Let's go ahead and __ignore__ the warning about the flat warping function. Note that `pattern_approxfun(..)` returns the linear function between ((0,0), (1,0)) in this case, so that `area_diff_2_functions()` works.

```{r fig.keep='all'}
signal_ext1 <- extract_signal_from_window(
  find_signal_w1, window = win1, throwIfFlat = FALSE)
signal_mat1 <- signal_ext1$data
signal_mat_f1 <- pattern_approxfun(signal_mat1, smooth = FALSE)

area_diff_2_functions(signal_org_f, signal_mat_f1)

curve(signal_org_f, 0, 1, col = "red")
curve(signal_mat_f1, 0, 1, add = TRUE)

print(paste0("The window starts at ", signal_ext1$start, " and ends at ", signal_ext1$end))
```




# Ideas

As Journal of Empirical Software Engineering (EISSN 1573-7616) article:

*   We take only one pattern (maybe include some more that do not require additional implementation in our tools, otherwise skip) -- the pattern we're currently interested in is __"Half Done Is Enough"__
*   We start by making best guesses for how we think each maintenance activity's distribution looks for when the pattern occurs (similar to how we modeled the example signal above; however, we need to model one signal for each activity, so that it (kind of) becomes a multivariate Kernel)
*   Using these best guesses and DTW, we try to detect the pattern in student projects
*   Then Petr/Premek will help us to corroborate our findings, and to adjust our best guess (e.g., length of time frames, function-match thresholds etc.)
*   Using the fine-tuned tools, we'll mine some of the bigger Apache projects. Btw., here's a recent article from that journal using such projects: https://link.springer.com/article/10.1007/s10664-020-09880-1


