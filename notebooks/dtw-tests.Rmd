---
title: "Tests with DTW"
output:
  pdf_document:
    number_sections: true
    toc: true
    toc_depth: 6
  md_document:
    df_print: paged
  html_document:
    df_print: paged
    number_sections: true
    toc: true
    toc_depth: 6
    toc_float: true
  word_document: default
---

In this notebook we want to test whether we can detect patterns in noisy data using dynamic time warping. We will generate some synthetic data for that.

```{r warning=FALSE, message=FALSE}
library(dtw)
```

# Create an Example Signal

In the following example, we assume the signal to look like Gauss bell, and that's what we'll be looking for later. The bell is generated by estimating a density over a normally distributed sample of 500 points. The shape is obtained by 256 equally spaced points at which the density is to be estimated over the sample.

```{r}
set.seed(1)

d <- density(rnorm(500), n = 256)

noisy_signal <- list(
  x = 1:(length(d$x) + 768),
  y = c(
    # Add random noise before:
    rnorm(n = 256, sd = 0.05) + (0.05 * rexp(n = 256)),
    # Add the actual signal with some noise:
    d$y + rnorm(n = length(d$x), sd = 0.05),
    # Add random noise after:
    rnorm(n = 512, sd = 0.05) + (0.15 * runif(n = 512))
  )
)

if (min(noisy_signal$y) < 0) {
  noisy_signal$y <- noisy_signal$y + abs(min(noisy_signal$y))
}

plot(noisy_signal)
```

# Create the Original Signal we want to find

Let's attempt to find Gauss bell. We will use a similar distribution first, before we alter it using $\mu$ and $\sigma$.

NOTE: In the few following tests, we are not using windowing, so the DTW algorithm attempts to match two sequences start to end!

```{r}
set.seed(2)

d1 <- density(rnorm(500, mean = 3), n = 256)

org_signal <- list(
  x = 1:length(d1$x),
  y = d1$y
)
```

# Use Dynamic Time Warping to find the pattern

```{r}
find_signal <- dtw::dtw(x = noisy_signal$y, y = org_signal$y, keep.internals = TRUE)

#par(mfrow=c(3,1))

plot(org_signal)

plot(noisy_signal)

plot(find_signal, type = "alignment")
plot(find_signal, type = "three")

print(c(find_signal$distance, find_signal$normalizedDistance))
```

## Define functions for assessing goodness-of-match

Before we go further, we want to extract the matching portions of the pattern from the window and compare it to the original signal. We approximate functions for the original and the matched signal and then calculate the difference as the area between the curves in a unit square.

```{r}
#' TODO: We should also return start/end index of
#' when the warping-function starts/ends
#' TODO: We should try to implement detecting a 'flat'
#' warping curve, as it indicates whether the pattern
#' is present (see last example in this notebook)
extract_signal_from_window <- function(dtwAlign, window) {
  indices <- c()
  for (idx in 1:min(length(window) - 1, length(dtwAlign$index2) - 1)) {
    if (dtwAlign$index2[idx] < dtwAlign$index2[idx + 1]) {
      indices <- c(indices, c(idx, idx + 1))
    }
  }
  
  indices <- unique(indices)
  
  return(window[indices])
}
```

Now we need to transform both, the original pattern and the matched pattern to be in the $[0,1]$ range.

After this, we want to approximate two functions. For the original pattern we use `approxfun`, and for the matched pattern we use a Loess-smoothed approximation.

```{r}
pattern_approxfun <- function(yData, smooth = FALSE) {
  if (smooth) {
    temp <- loess.smooth(
      x = 1:length(yData),
      y = yData,
      span = 0.1
    )
    
    yData <- temp$y
    xData <- temp$x - min(temp$x)
    xData <- xData / max(xData)
  } else {
    xData <- seq(0, 1, by = 1 / (length(yData) - 1))
  }
  
  yData <- yData - min(yData)
  yData <- yData / max(yData)
  
  return(approxfun(
    x = xData,
    y = yData
  ))
}
```

Now that we can approximate both patterns as a function in the unit square, we will look for intersections, so that we can integrate and sum up all differences between the two functions.

```{r}
area_diff_2_functions <- function(f1, f2) {
  # Find the intersections of both functions:
  intersections <- rootSolve::uniroot.all(
    f = function(x) f1(x) - f2(x),
    interval = c(0, 1))
  
  if (length(intersections) == 0) {
    # One function is complete below/above the other
    intersections <- c(0, 1)
  }
  
  # Check that lower/upper integration boundaries exist:
  if (intersections[1] > 0) {
    intersections <- c(0, intersections)
  }
  if (utils::tail(intersections, 1) < 1) {
    intersections <- c(intersections, 1)
  }
  
  # Now, for each pair of intersections, we integrate both
  # functions and sum up the areas.
  
  area <- 0
  for (intsec in 1:(length(intersections) - 1)) {
    temp <- abs(
      stats::integrate(
        f = f1,
        lower = intersections[intsec],
        upper = intersections[intsec + 1])$value
      -
      stats::integrate(
        f = f2,
        lower = intersections[intsec],
        upper = intersections[intsec + 1])$value)
    
    area <- area + temp
  }
  
  return(area)
}
```

### Example using no Window

Let's do a full example using the match from above. We do not have a window, so we use the entire warping function to extract matches of our sought-after pattern. We will use smoothing since no window is used:

```{r fig.keep='all'}
signal_org_f <- pattern_approxfun(org_signal$y)

signal_mat3 <- extract_signal_from_window(find_signal, window = stats::window(noisy_signal$y))
signal_mat_f3 <- pattern_approxfun(signal_mat3, smooth = TRUE)

print(paste0("The difference in area is (max 1): ", area_diff_2_functions(signal_org_f, signal_mat_f3)))

curve(signal_org_f, 0, 1, col = "red")
curve(signal_mat_f3, 0, 1, add = TRUE)
```

### Example using a Window

Try the same with a window that closer encapsulates the pattern (the pattern starts at 256 with a length of 256):

```{r}
win <- stats::window(noisy_signal$y, start = 220, end = 594)
plot(list(
  x = 1:length(win),
  y = win
))

# Note how we use a different step.pattern.
# The default is 'symmetric2'.
# It should be remarked that the Sakoe-Chiba band works well when N ~ M, but is inappropriate when the lengths of the two inputs differ significantly. In particular, when |N - M| > T_0.
# Argument 'dist.method' does not make since with univariate time series
find_signal_w <- dtw::dtw(
  x = win, y = org_signal$y, keep.internals = TRUE,
  step.pattern = asymmetric,
  #step.pattern = rabinerJuangStepPattern(1, slope.weighting = "c", smoothed = TRUE),
  open.end = TRUE,
  open.begin = TRUE)

plot(find_signal_w, type = "alignment")
plot(find_signal_w, type = "two")
plot(find_signal_w, type = "three")

print(c(find_signal_w$distance, find_signal_w$normalizedDistance))
```


Let's do a full example using the match from above:

```{r fig.keep='all'}
signal_org_f <- pattern_approxfun(org_signal$y)

signal_mat <- extract_signal_from_window(find_signal_w, window = win)
signal_mat_f <- pattern_approxfun(signal_mat, smooth = TRUE)

curve(signal_org_f, 0, 1, col = "red")
curve(signal_mat_f, 0, 1, add = TRUE)
```
Now the area between the curves in the unit square is:
```{r}
area_diff_2_functions(signal_org_f, signal_mat_f)
```


### Example using a partially matching window:

Try the same with a window that only PARTIALLY contains the pattern:

```{r}
win2 <- stats::window(noisy_signal$y, start = 384, end = 800)
plot(list(
  x = 1:length(win2),
  y = win2
))

find_signal_w2 <- dtw::dtw(
  x = win2, y = org_signal$y, keep.internals = TRUE,
  step.pattern = asymmetric,
#  step.pattern = rabinerJuangStepPattern(1, slope.weighting = "c", smoothed = TRUE),
  open.end = TRUE,
  open.begin = TRUE)

plot(find_signal_w2, type = "alignment")
plot(find_signal_w2, type = "two")
plot(find_signal_w2, type = "three")

print(c(find_signal_w2$distance, find_signal_w2$normalizedDistance))
```

```{r fig.keep='all'}
signal_mat2 <- extract_signal_from_window(find_signal_w2, window = win2)
signal_mat_f2 <- pattern_approxfun(signal_mat2, smooth = FALSE)

area_diff_2_functions(signal_org_f, signal_mat_f2)

curve(signal_org_f, 0, 1, col = "red")
curve(signal_mat_f2, 0, 1, add = TRUE)
```

### Example with a window that does not contain the pattern:

Try the same with a window that does NOT contain the pattern:
```{r}
win1 <- stats::window(noisy_signal$y, start = 650, end = 1024)
plot(list(
  x = 1:length(win1),
  y = win1
))

find_signal_w1 <- dtw::dtw(
  x = win1, y = org_signal$y, keep.internals = TRUE,
  step.pattern = asymmetric,
#  step.pattern = rabinerJuangStepPattern(1, slope.weighting = "c", smoothed = TRUE),
  open.end = TRUE,
  open.begin = TRUE)

plot(find_signal_w1, type = "alignment")
plot(find_signal_w1, type = "two")
plot(find_signal_w1, type = "three")

print(c(find_signal_w1$distance, find_signal_w1$normalizedDistance))
```


```{r fig.keep='all'}
signal_mat1 <- extract_signal_from_window(find_signal_w1, window = win1)
signal_mat_f1 <- pattern_approxfun(signal_mat1, smooth = FALSE)

area_diff_2_functions(signal_org_f, signal_mat_f1)

curve(signal_org_f, 0, 1, col = "red")
curve(signal_mat_f1, 0, 1, add = TRUE)
```




# Ideas

As Journal of Empirical Software Engineering (EISSN 1573-7616) article:

*   We take only one pattern (maybe include some more that do not require additional implementation in our tools, otherwise skip) -- the pattern we're currently interested in is __"Half Done Is Enough"__
*   We start by making best guesses for how we think each maintenance activity's distribution looks for when the pattern occurs (similar to how we modeled the example signal above; however, we need to model one signal for each activity, so that it (kind of) becomes a multivariate Kernel)
*   Using these best guesses and DTW, we try to detect the pattern in student projects
*   Then Petr/Premek will help us to corroborate our findings, and to adjust our best guess (e.g., length of time frames, function-match thresholds etc.)
*   Using the fine-tuned tools, we'll mine some of the bigger Apache projects. Btw., here's a recent article from that journal using such projects: https://link.springer.com/article/10.1007/s10664-020-09880-1


